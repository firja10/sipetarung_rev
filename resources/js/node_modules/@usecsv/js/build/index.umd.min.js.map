{"version":3,"file":"index.umd.min.js","sources":["../node_modules/insert-css/index.js","../node_modules/penpal/lib/enums.js","../node_modules/penpal/lib/parent/getOriginFromSrc.js","../node_modules/penpal/lib/errorSerialization.js","../node_modules/penpal/lib/generateId.js","../node_modules/penpal/lib/connectCallSender.js","../node_modules/penpal/lib/parent/handleAckMessageFactory.js","../node_modules/penpal/lib/connectCallReceiver.js","../node_modules/penpal/lib/parent/connectToChild.js","../node_modules/penpal/lib/createLogger.js","../node_modules/penpal/lib/createDestructor.js","../node_modules/penpal/lib/parent/validateIframeHasSrcOrSrcDoc.js","../node_modules/penpal/lib/parent/handleSynMessageFactory.js","../node_modules/penpal/lib/startConnectionTimeout.js","../node_modules/penpal/lib/parent/monitorIframeRemoval.js","../node_modules/when-dom-ready/dist/index.es2015.js","../src/lib/useCsvPlugin.ts"],"sourcesContent":["var containers = []; // will store container HTMLElement references\nvar styleElements = []; // will store {prepend: HTMLElement, append: HTMLElement}\n\nvar usage = 'insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).';\n\nfunction insertCss(css, options) {\n    options = options || {};\n\n    if (css === undefined) {\n        throw new Error(usage);\n    }\n\n    var position = options.prepend === true ? 'prepend' : 'append';\n    var container = options.container !== undefined ? options.container : document.querySelector('head');\n    var containerId = containers.indexOf(container);\n\n    // first time we see this container, create the necessary entries\n    if (containerId === -1) {\n        containerId = containers.push(container) - 1;\n        styleElements[containerId] = {};\n    }\n\n    // try to get the correponding container + position styleElement, create it otherwise\n    var styleElement;\n\n    if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {\n        styleElement = styleElements[containerId][position];\n    } else {\n        styleElement = styleElements[containerId][position] = createStyleElement();\n\n        if (position === 'prepend') {\n            container.insertBefore(styleElement, container.childNodes[0]);\n        } else {\n            container.appendChild(styleElement);\n        }\n    }\n\n    // strip potential UTF-8 BOM if css was read from a file\n    if (css.charCodeAt(0) === 0xFEFF) { css = css.substr(1, css.length); }\n\n    // actually add the stylesheet\n    if (styleElement.styleSheet) {\n        styleElement.styleSheet.cssText += css\n    } else {\n        styleElement.textContent += css;\n    }\n\n    return styleElement;\n};\n\nfunction createStyleElement() {\n    var styleElement = document.createElement('style');\n    styleElement.setAttribute('type', 'text/css');\n    return styleElement;\n}\n\nmodule.exports = insertCss;\nmodule.exports.insertCss = insertCss;\n","export var MessageType;\n(function (MessageType) {\n    MessageType[\"Call\"] = \"call\";\n    MessageType[\"Reply\"] = \"reply\";\n    MessageType[\"Syn\"] = \"syn\";\n    MessageType[\"SynAck\"] = \"synAck\";\n    MessageType[\"Ack\"] = \"ack\";\n})(MessageType || (MessageType = {}));\nexport var Resolution;\n(function (Resolution) {\n    Resolution[\"Fulfilled\"] = \"fulfilled\";\n    Resolution[\"Rejected\"] = \"rejected\";\n})(Resolution || (Resolution = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[\"ConnectionDestroyed\"] = \"ConnectionDestroyed\";\n    ErrorCode[\"ConnectionTimeout\"] = \"ConnectionTimeout\";\n    ErrorCode[\"NoIframeSrc\"] = \"NoIframeSrc\";\n})(ErrorCode || (ErrorCode = {}));\nexport var NativeErrorName;\n(function (NativeErrorName) {\n    NativeErrorName[\"DataCloneError\"] = \"DataCloneError\";\n})(NativeErrorName || (NativeErrorName = {}));\nexport var NativeEventType;\n(function (NativeEventType) {\n    NativeEventType[\"Message\"] = \"message\";\n})(NativeEventType || (NativeEventType = {}));\n","const DEFAULT_PORT_BY_PROTOCOL = {\n    'http:': '80',\n    'https:': '443',\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n */\nexport default (src) => {\n    if (src && opaqueOriginSchemes.find((scheme) => src.startsWith(scheme))) {\n        // The origin of the child document is an opaque origin and its\n        // serialization is \"null\"\n        // https://html.spec.whatwg.org/multipage/origin.html#origin\n        return 'null';\n    }\n    // Note that if src is undefined, then srcdoc is being used instead of src\n    // and we can follow this same logic below to get the origin of the parent,\n    // which is the origin that we will need to use.\n    const location = document.location;\n    const regexResult = URL_REGEX.exec(src);\n    let protocol;\n    let hostname;\n    let port;\n    if (regexResult) {\n        // It's an absolute URL. Use the parsed info.\n        // regexResult[1] will be undefined if the URL starts with //\n        protocol = regexResult[1] ? regexResult[1] : location.protocol;\n        hostname = regexResult[2];\n        port = regexResult[4];\n    }\n    else {\n        // It's a relative path. Use the current location's info.\n        protocol = location.protocol;\n        hostname = location.hostname;\n        port = location.port;\n    }\n    // If the port is the default for the protocol, we don't want to add it to the origin string\n    // or it won't match the message's event.origin.\n    const portSuffix = port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : '';\n    return `${protocol}//${hostname}${portSuffix}`;\n};\n","/**\n * Converts an error object into a plain object.\n */\nexport const serializeError = ({ name, message, stack, }) => ({\n    name,\n    message,\n    stack,\n});\n/**\n * Converts a plain object into an error object.\n */\nexport const deserializeError = (obj) => {\n    const deserializedError = new Error();\n    // @ts-ignore\n    Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));\n    return deserializedError;\n};\n","let id = 0;\n/**\n * @return {number} A unique ID (not universally unique)\n */\nexport default () => ++id;\n","import generateId from './generateId';\nimport { deserializeError } from './errorSerialization';\nimport { ErrorCode, MessageType, NativeEventType, Resolution } from './enums';\n/**\n * Augments an object with methods that match those defined by the remote. When these methods are\n * called, a \"call\" message will be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n * @param {Object} callSender Sender object that should be augmented with methods.\n * @param {Object} info Information about the local and remote windows.\n * @param {Array} methodNames Names of methods available to be called on the remote.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Object} The call sender object with methods that may be called.\n */\nexport default (callSender, info, methodNames, destroyConnection, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    log(`${localName}: Connecting call sender`);\n    const createMethodProxy = (methodName) => {\n        return (...args) => {\n            log(`${localName}: Sending ${methodName}() call`);\n            // This handles the case where the iframe has been removed from the DOM\n            // (and therefore its window closed), the consumer has not yet\n            // called destroy(), and the user calls a method exposed by\n            // the remote. We detect the iframe has been removed and force\n            // a destroy() immediately so that the consumer sees the error saying\n            // the connection has been destroyed. We wrap this check in a try catch\n            // because Edge throws an \"Object expected\" error when accessing\n            // contentWindow.closed on a contentWindow from an iframe that's been\n            // removed from the DOM.\n            let iframeRemoved;\n            try {\n                if (remote.closed) {\n                    iframeRemoved = true;\n                }\n            }\n            catch (e) {\n                iframeRemoved = true;\n            }\n            if (iframeRemoved) {\n                destroyConnection();\n            }\n            if (destroyed) {\n                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);\n                error.code = ErrorCode.ConnectionDestroyed;\n                throw error;\n            }\n            return new Promise((resolve, reject) => {\n                const id = generateId();\n                const handleMessageEvent = (event) => {\n                    if (event.source !== remote ||\n                        event.data.penpal !== MessageType.Reply ||\n                        event.data.id !== id) {\n                        return;\n                    }\n                    if (event.origin !== originForReceiving) {\n                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n                        return;\n                    }\n                    const replyMessage = event.data;\n                    log(`${localName}: Received ${methodName}() reply`);\n                    local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n                    let returnValue = replyMessage.returnValue;\n                    if (replyMessage.returnValueIsError) {\n                        returnValue = deserializeError(returnValue);\n                    }\n                    (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);\n                };\n                local.addEventListener(NativeEventType.Message, handleMessageEvent);\n                const callMessage = {\n                    penpal: MessageType.Call,\n                    id,\n                    methodName,\n                    args,\n                };\n                remote.postMessage(callMessage, originForSending);\n            });\n        };\n    };\n    methodNames.reduce((api, methodName) => {\n        api[methodName] = createMethodProxy(methodName);\n        return api;\n    }, callSender);\n    return () => {\n        destroyed = true;\n    };\n};\n","import connectCallReceiver from '../connectCallReceiver';\nimport connectCallSender from '../connectCallSender';\n/**\n * Handles an ACK handshake message.\n */\nexport default (methods, childOrigin, originForSending, destructor, log) => {\n    const { destroy, onDestroy } = destructor;\n    let destroyCallReceiver;\n    let receiverMethodNames;\n    // We resolve the promise with the call sender. If the child reconnects\n    // (for example, after refreshing or navigating to another page that\n    // uses Penpal, we'll update the call sender with methods that match the\n    // latest provided by the child.\n    const callSender = {};\n    return (event) => {\n        if (event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received ACK');\n        const info = {\n            localName: 'Parent',\n            local: window,\n            remote: event.source,\n            originForSending: originForSending,\n            originForReceiving: childOrigin,\n        };\n        // If the child reconnected, we need to destroy the prior call receiver\n        // before setting up a new one.\n        if (destroyCallReceiver) {\n            destroyCallReceiver();\n        }\n        destroyCallReceiver = connectCallReceiver(info, methods, log);\n        onDestroy(destroyCallReceiver);\n        // If the child reconnected, we need to remove the methods from the\n        // previous call receiver off the sender.\n        if (receiverMethodNames) {\n            receiverMethodNames.forEach((receiverMethodName) => {\n                delete callSender[receiverMethodName];\n            });\n        }\n        receiverMethodNames = event.data.methodNames;\n        const destroyCallSender = connectCallSender(callSender, info, receiverMethodNames, destroy, log);\n        onDestroy(destroyCallSender);\n        return callSender;\n    };\n};\n","import { serializeError } from './errorSerialization';\nimport { MessageType, NativeEventType, NativeErrorName, Resolution, } from './enums';\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n */\nexport default (info, methods, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    const handleMessageEvent = (event) => {\n        if (event.source !== remote || event.data.penpal !== MessageType.Call) {\n            return;\n        }\n        if (event.origin !== originForReceiving) {\n            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n            return;\n        }\n        const callMessage = event.data;\n        const { methodName, args, id } = callMessage;\n        log(`${localName}: Received ${methodName}() call`);\n        const createPromiseHandler = (resolution) => {\n            return (returnValue) => {\n                log(`${localName}: Sending ${methodName}() reply`);\n                if (destroyed) {\n                    // It's possible to throw an error here, but it would need to be thrown asynchronously\n                    // and would only be catchable using window.onerror. This is because the consumer\n                    // is merely returning a value from their method and not calling any function\n                    // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n                    // the value of doing so is questionable. Instead, we'll just log a message.\n                    log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n                    return;\n                }\n                const message = {\n                    penpal: MessageType.Reply,\n                    id,\n                    resolution,\n                    returnValue,\n                };\n                if (resolution === Resolution.Rejected &&\n                    returnValue instanceof Error) {\n                    message.returnValue = serializeError(returnValue);\n                    message.returnValueIsError = true;\n                }\n                try {\n                    remote.postMessage(message, originForSending);\n                }\n                catch (err) {\n                    // If a consumer attempts to send an object that's not cloneable (e.g., window),\n                    // we want to ensure the receiver's promise gets rejected.\n                    if (err.name === NativeErrorName.DataCloneError) {\n                        const errorReplyMessage = {\n                            penpal: MessageType.Reply,\n                            id,\n                            resolution: Resolution.Rejected,\n                            returnValue: serializeError(err),\n                            returnValueIsError: true,\n                        };\n                        remote.postMessage(errorReplyMessage, originForSending);\n                    }\n                    throw err;\n                }\n            };\n        };\n        new Promise((resolve) => resolve(methods[methodName].apply(methods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));\n    };\n    local.addEventListener(NativeEventType.Message, handleMessageEvent);\n    return () => {\n        destroyed = true;\n        local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n    };\n};\n","import { MessageType, NativeEventType } from '../enums';\nimport createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport getOriginFromSrc from './getOriginFromSrc';\nimport handleAckMessageFactory from './handleAckMessageFactory';\nimport handleSynMessageFactory from './handleSynMessageFactory';\nimport monitorIframeRemoval from './monitorIframeRemoval';\nimport startConnectionTimeout from '../startConnectionTimeout';\nimport validateIframeHasSrcOrSrcDoc from './validateIframeHasSrcOrSrcDoc';\n/**\n * Attempts to establish communication with an iframe.\n */\nexport default (options) => {\n    let { iframe, methods = {}, childOrigin, timeout, debug = false } = options;\n    const log = createLogger(debug);\n    const destructor = createDestructor('Parent', log);\n    const { onDestroy, destroy } = destructor;\n    if (!childOrigin) {\n        validateIframeHasSrcOrSrcDoc(iframe);\n        childOrigin = getOriginFromSrc(iframe.src);\n    }\n    // If event.origin is \"null\", the remote protocol is file: or data: and we\n    // must post messages with \"*\" as targetOrigin when sending messages.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions\n    const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n    const handleSynMessage = handleSynMessageFactory(log, methods, childOrigin, originForSending);\n    const handleAckMessage = handleAckMessageFactory(methods, childOrigin, originForSending, destructor, log);\n    const promise = new Promise((resolve, reject) => {\n        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n        const handleMessage = (event) => {\n            if (event.source !== iframe.contentWindow || !event.data) {\n                return;\n            }\n            if (event.data.penpal === MessageType.Syn) {\n                handleSynMessage(event);\n                return;\n            }\n            if (event.data.penpal === MessageType.Ack) {\n                const callSender = handleAckMessage(event);\n                if (callSender) {\n                    stopConnectionTimeout();\n                    resolve(callSender);\n                }\n                return;\n            }\n        };\n        window.addEventListener(NativeEventType.Message, handleMessage);\n        log('Parent: Awaiting handshake');\n        monitorIframeRemoval(iframe, destructor);\n        onDestroy((error) => {\n            window.removeEventListener(NativeEventType.Message, handleMessage);\n            if (error) {\n                reject(error);\n            }\n        });\n    });\n    return {\n        promise,\n        destroy() {\n            // Don't allow consumer to pass an error into destroy.\n            destroy();\n        },\n    };\n};\n","export default (debug) => {\n    /**\n     * Logs a message if debug is enabled.\n     */\n    return (...args) => {\n        if (debug) {\n            console.log('[Penpal]', ...args); // eslint-disable-line no-console\n        }\n    };\n};\n","export default (localName, log) => {\n    const callbacks = [];\n    let destroyed = false;\n    return {\n        destroy(error) {\n            if (!destroyed) {\n                destroyed = true;\n                log(`${localName}: Destroying connection`);\n                callbacks.forEach((callback) => {\n                    callback(error);\n                });\n            }\n        },\n        onDestroy(callback) {\n            destroyed ? callback() : callbacks.push(callback);\n        },\n    };\n};\n","import { ErrorCode } from '../enums';\nexport default (iframe) => {\n    if (!iframe.src && !iframe.srcdoc) {\n        const error = new Error('Iframe must have src or srcdoc property defined.');\n        error.code = ErrorCode.NoIframeSrc;\n        throw error;\n    }\n};\n","import { MessageType } from '../enums';\n/**\n * Handles a SYN handshake message.\n */\nexport default (log, methods, childOrigin, originForSending) => {\n    return (event) => {\n        if (event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received SYN message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received SYN, responding with SYN-ACK');\n        const synAckMessage = {\n            penpal: MessageType.SynAck,\n            methodNames: Object.keys(methods),\n        };\n        event.source.postMessage(synAckMessage, originForSending);\n    };\n};\n","import { ErrorCode } from './enums';\n/**\n * Starts a timeout and calls the callback with an error\n * if the timeout completes before the stop function is called.\n */\nexport default (timeout, callback) => {\n    let timeoutId;\n    if (timeout !== undefined) {\n        timeoutId = window.setTimeout(() => {\n            const error = new Error(`Connection timed out after ${timeout}ms`);\n            error.code = ErrorCode.ConnectionTimeout;\n            callback(error);\n        }, timeout);\n    }\n    return () => {\n        clearTimeout(timeoutId);\n    };\n};\n","const CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * Monitors for iframe removal and destroys connection if iframe\n * is found to have been removed from DOM. This is to prevent memory\n * leaks when the iframe is removed from the document and the consumer\n * hasn't called destroy(). Without this, event listeners attached to\n * the window would stick around and since the event handlers have a\n * reference to the iframe in their closures, the iframe would stick\n * around too.\n */\nexport default (iframe, destructor) => {\n    const { destroy, onDestroy } = destructor;\n    const checkIframeInDocIntervalId = setInterval(() => {\n        if (!iframe.isConnected) {\n            clearInterval(checkIframeInDocIntervalId);\n            destroy();\n        }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n        clearInterval(checkIframeInDocIntervalId);\n    });\n};\n","/* eslint no-void: \"off\" */\n\n// Loaded ready states\nvar loadedStates = ['interactive', 'complete'];\n\n// Return Promise\nvar whenDomReady = function whenDomReady(cb, doc) {\n\treturn new Promise(function (resolve) {\n\t\t// Allow doc to be passed in as the lone first param\n\t\tif (cb && typeof cb !== 'function') {\n\t\t\tdoc = cb;\n\t\t\tcb = null;\n\t\t}\n\n\t\t// Use global document if we don't have one\n\t\tdoc = doc || window.document;\n\n\t\t// Handle DOM load\n\t\tvar done = function done() {\n\t\t\treturn resolve(void (cb && setTimeout(cb)));\n\t\t};\n\n\t\t// Resolve now if DOM has already loaded\n\t\t// Otherwise wait for DOMContentLoaded\n\t\tif (loadedStates.indexOf(doc.readyState) !== -1) {\n\t\t\tdone();\n\t\t} else {\n\t\t\tdoc.addEventListener('DOMContentLoaded', done);\n\t\t}\n\t});\n};\n\n// Promise chain helper\nwhenDomReady.resume = function (doc) {\n\treturn function (val) {\n\t\treturn whenDomReady(doc).then(function () {\n\t\t\treturn val;\n\t\t});\n\t};\n};\n\nexport default whenDomReady;\n//# sourceMappingURL=index.es2015.js.map\n","import { insertCss } from \"insert-css\";\nimport { connectToChild } from \"penpal\";\nimport whenDomReady from \"when-dom-ready\";\n\nimport type { CsvData, onRecordEditType, onRecordsInitialType } from \"./types\";\n\n// eslint-disable-next-line dot-notation\nconst MOUNT_URL = process.env[\"MOUNT_URL\"] || \"http://localhost:3000/importer\";\n\nconst insertIframe = (id: string, importerDisplay: \"inline\" | \"modal\") => {\n  const usecsvInlineWrapper = document.getElementById(\"usecsv-importer-inline-wrapper\");\n\n  const usecsvContainerStyles =\n    importerDisplay === \"modal\" || !usecsvInlineWrapper\n      ? `.usecsv_container { position: fixed; top: 0px; bottom: 0; right: 0; left: 0; z-index: 100000; }`\n      : ``;\n\n  insertCss(`\n  ${usecsvContainerStyles}\n  .usecsv_container iframe {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    border-width: 0;\n  }\n  .usecsv_container {\n    overflow: hidden;\n    overscroll-behavior-x: none;\n  }\n`);\n\n  document.body.insertAdjacentHTML(\"beforeend\", `<div id=${id} class=\"usecsv_container loading\"></div>`);\n  const iframe = document.createElement(\"iframe\");\n  iframe.setAttribute(\"src\", MOUNT_URL);\n  const usecsvContainer = document.getElementById(id);\n  usecsvContainer?.appendChild(iframe);\n  if (importerDisplay === \"inline\" && usecsvInlineWrapper) {\n    // usecsvInlineWrapper > usecsvContainer > iframe\n    usecsvInlineWrapper?.appendChild(usecsvContainer as HTMLElement);\n  }\n\n  return iframe;\n};\n\nconst useCsvPlugin = ({\n  importerKey,\n  user,\n  metadata,\n  onData,\n  onRecordsInitial,\n  onRecordEdit,\n  importerDisplay = \"modal\",\n  onClose,\n}: {\n  importerKey: string;\n  user?: Record<string, string | number>;\n  metadata?: Record<string, string | number>;\n  onData?: (\n    data: CsvData,\n    close: () => void,\n  ) => void | Promise<{\n    errors?: {\n      row: Record<string, string | number | undefined>;\n      error: string;\n    }[];\n  } | void>;\n  onRecordsInitial?: onRecordsInitialType;\n  onRecordEdit?: onRecordEditType;\n  importerDisplay?: \"modal\" | \"inline\";\n  onClose?: () => void;\n}) => {\n  const id = `usecsv-${Math.round(Math.random() * 100000000)}`;\n  return whenDomReady().then(() => {\n    const iframe = insertIframe(id, importerDisplay);\n    const closeIframe = () => {\n      document.getElementById(id)?.remove();\n    };\n    const iframeConnection = connectToChild({\n      iframe,\n      methods: {\n        closeIframe,\n        ...(onData\n          ? {\n              onData: (data: CsvData) => onData(data, closeIframe),\n            }\n          : {}),\n        ...(onRecordsInitial\n          ? {\n              onRecordsInitial,\n            }\n          : {}),\n        ...(onRecordEdit\n          ? {\n              onRecordEdit,\n            }\n          : {}),\n        ...(onClose\n          ? {\n              onClose,\n            }\n          : {}),\n      },\n    });\n    iframeConnection.promise.then((child: any) => {\n      document.getElementById(id)?.classList.remove(\"loading\");\n      // eslint-disable-next-line dot-notation\n      child[\"setParams\"] && child[\"setParams\"]({ importerKey, user, metadata, importerDisplay });\n    });\n    return iframeConnection;\n  });\n};\n\nexport default useCsvPlugin;\n"],"names":["containers","styleElements","insertCss","css","options","undefined","Error","styleElement","position","prepend","container","document","querySelector","containerId","indexOf","push","createElement","setAttribute","createStyleElement","insertBefore","childNodes","appendChild","charCodeAt","substr","length","styleSheet","cssText","textContent","MessageType","Resolution","ErrorCode","NativeErrorName","NativeEventType","DEFAULT_PORT_BY_PROTOCOL","URL_REGEX","opaqueOriginSchemes","serializeError","name","message","stack","id","callSender","info","methodNames","destroyConnection","log","localName","local","remote","originForSending","originForReceiving","destroyed","createMethodProxy","methodName","args","iframeRemoved","closed","e","error","code","ConnectionDestroyed","Promise","resolve","reject","generateId","handleMessageEvent","event","source","data","penpal","Reply","origin","replyMessage","removeEventListener","Message","returnValue","returnValueIsError","obj","deserializedError","Object","keys","forEach","key","deserializeError","resolution","Fulfilled","addEventListener","callMessage","Call","postMessage","reduce","api","methods","childOrigin","destructor","destroy","onDestroy","destroyCallReceiver","receiverMethodNames","window","createPromiseHandler","Rejected","err","DataCloneError","errorReplyMessage","apply","then","connectCallReceiver","receiverMethodName","destroyCallSender","connectCallSender","iframe","timeout","debug","console","createLogger","callbacks","callback","createDestructor","src","srcdoc","NoIframeSrc","validateIframeHasSrcOrSrcDoc","find","scheme","startsWith","location","regexResult","exec","protocol","hostname","port","getOriginFromSrc","handleSynMessage","synAckMessage","SynAck","handleSynMessageFactory","handleAckMessage","handleAckMessageFactory","promise","stopConnectionTimeout","timeoutId","setTimeout","ConnectionTimeout","clearTimeout","startConnectionTimeout","handleMessage","contentWindow","Syn","Ack","checkIframeInDocIntervalId","setInterval","isConnected","clearInterval","monitorIframeRemoval","loadedStates","whenDomReady","cb","doc","done","readyState","resume","val","_a","importerKey","user","metadata","onData","onRecordsInitial","onRecordEdit","_b","importerDisplay","onClose","Math","round","random","usecsvInlineWrapper","getElementById","body","insertAdjacentHTML","usecsvContainer","insertIframe","closeIframe","remove","iframeConnection","connectToChild","child","classList"],"mappings":"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"}